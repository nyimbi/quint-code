// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addCharacteristic = `-- name: AddCharacteristic :exec

INSERT INTO characteristics (id, holon_id, name, scale, value, unit, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type AddCharacteristicParams struct {
	ID        string
	HolonID   string
	Name      string
	Scale     string
	Value     string
	Unit      sql.NullString
	CreatedAt sql.NullTime
}

// Characteristic queries
func (q *Queries) AddCharacteristic(ctx context.Context, db DBTX, arg AddCharacteristicParams) error {
	_, err := db.ExecContext(ctx, addCharacteristic,
		arg.ID,
		arg.HolonID,
		arg.Name,
		arg.Scale,
		arg.Value,
		arg.Unit,
		arg.CreatedAt,
	)
	return err
}

const addEvidence = `-- name: AddEvidence :exec

INSERT INTO evidence (id, holon_id, type, content, verdict, assurance_level, carrier_ref, valid_until, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type AddEvidenceParams struct {
	ID             string
	HolonID        string
	Type           string
	Content        string
	Verdict        string
	AssuranceLevel sql.NullString
	CarrierRef     sql.NullString
	ValidUntil     sql.NullTime
	CreatedAt      sql.NullTime
}

// Evidence queries
func (q *Queries) AddEvidence(ctx context.Context, db DBTX, arg AddEvidenceParams) error {
	_, err := db.ExecContext(ctx, addEvidence,
		arg.ID,
		arg.HolonID,
		arg.Type,
		arg.Content,
		arg.Verdict,
		arg.AssuranceLevel,
		arg.CarrierRef,
		arg.ValidUntil,
		arg.CreatedAt,
	)
	return err
}

const addRelation = `-- name: AddRelation :exec

INSERT INTO relations (source_id, target_id, relation_type, created_at)
VALUES (?, ?, ?, ?)
`

type AddRelationParams struct {
	SourceID     string
	TargetID     string
	RelationType string
	CreatedAt    sql.NullTime
}

// Relation queries
func (q *Queries) AddRelation(ctx context.Context, db DBTX, arg AddRelationParams) error {
	_, err := db.ExecContext(ctx, addRelation,
		arg.SourceID,
		arg.TargetID,
		arg.RelationType,
		arg.CreatedAt,
	)
	return err
}

const createHolon = `-- name: CreateHolon :exec


INSERT INTO holons (id, type, kind, layer, title, content, context_id, scope, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHolonParams struct {
	ID        string
	Type      string
	Kind      sql.NullString
	Layer     string
	Title     string
	Content   string
	ContextID string
	Scope     sql.NullString
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
}

// query.sql
// sqlc queries for FPF database operations
// Holon queries
func (q *Queries) CreateHolon(ctx context.Context, db DBTX, arg CreateHolonParams) error {
	_, err := db.ExecContext(ctx, createHolon,
		arg.ID,
		arg.Type,
		arg.Kind,
		arg.Layer,
		arg.Title,
		arg.Content,
		arg.ContextID,
		arg.Scope,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const getCharacteristics = `-- name: GetCharacteristics :many
SELECT id, holon_id, name, scale, value, unit, created_at FROM characteristics WHERE holon_id = ?
`

func (q *Queries) GetCharacteristics(ctx context.Context, db DBTX, holonID string) ([]Characteristic, error) {
	rows, err := db.QueryContext(ctx, getCharacteristics, holonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Characteristic
	for rows.Next() {
		var i Characteristic
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Name,
			&i.Scale,
			&i.Value,
			&i.Unit,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComponentsOf = `-- name: GetComponentsOf :many
SELECT source_id, congruence_level FROM relations
WHERE target_id = ? AND relation_type = 'componentOf'
`

type GetComponentsOfRow struct {
	SourceID        string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) GetComponentsOf(ctx context.Context, db DBTX, targetID string) ([]GetComponentsOfRow, error) {
	rows, err := db.QueryContext(ctx, getComponentsOf, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetComponentsOfRow
	for rows.Next() {
		var i GetComponentsOfRow
		if err := rows.Scan(&i.SourceID, &i.CongruenceLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvidenceByHolon = `-- name: GetEvidenceByHolon :many
SELECT id, holon_id, type, content, verdict, assurance_level, carrier_ref, valid_until, created_at FROM evidence WHERE holon_id = ? ORDER BY created_at DESC
`

func (q *Queries) GetEvidenceByHolon(ctx context.Context, db DBTX, holonID string) ([]Evidence, error) {
	rows, err := db.QueryContext(ctx, getEvidenceByHolon, holonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evidence
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.Content,
			&i.Verdict,
			&i.AssuranceLevel,
			&i.CarrierRef,
			&i.ValidUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvidenceWithCarrier = `-- name: GetEvidenceWithCarrier :many
SELECT id, holon_id, type, content, verdict, assurance_level, carrier_ref, valid_until, created_at FROM evidence WHERE carrier_ref IS NOT NULL AND carrier_ref != ''
`

func (q *Queries) GetEvidenceWithCarrier(ctx context.Context, db DBTX) ([]Evidence, error) {
	rows, err := db.QueryContext(ctx, getEvidenceWithCarrier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evidence
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.Content,
			&i.Verdict,
			&i.AssuranceLevel,
			&i.CarrierRef,
			&i.ValidUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHolon = `-- name: GetHolon :one
SELECT id, type, kind, layer, title, content, context_id, scope, cached_r_score, created_at, updated_at FROM holons WHERE id = ? LIMIT 1
`

func (q *Queries) GetHolon(ctx context.Context, db DBTX, id string) (Holon, error) {
	row := db.QueryRowContext(ctx, getHolon, id)
	var i Holon
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Kind,
		&i.Layer,
		&i.Title,
		&i.Content,
		&i.ContextID,
		&i.Scope,
		&i.CachedRScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHolonTitle = `-- name: GetHolonTitle :one
SELECT title FROM holons WHERE id = ? LIMIT 1
`

func (q *Queries) GetHolonTitle(ctx context.Context, db DBTX, id string) (string, error) {
	row := db.QueryRowContext(ctx, getHolonTitle, id)
	var title string
	err := row.Scan(&title)
	return title, err
}

const getRelationsByTarget = `-- name: GetRelationsByTarget :many
SELECT source_id, target_id, relation_type, congruence_level, created_at FROM relations WHERE target_id = ? AND relation_type = ?
`

type GetRelationsByTargetParams struct {
	TargetID     string
	RelationType string
}

func (q *Queries) GetRelationsByTarget(ctx context.Context, db DBTX, arg GetRelationsByTargetParams) ([]Relation, error) {
	rows, err := db.QueryContext(ctx, getRelationsByTarget, arg.TargetID, arg.RelationType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Relation
	for rows.Next() {
		var i Relation
		if err := rows.Scan(
			&i.SourceID,
			&i.TargetID,
			&i.RelationType,
			&i.CongruenceLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllHolonIDs = `-- name: ListAllHolonIDs :many
SELECT id FROM holons
`

func (q *Queries) ListAllHolonIDs(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.QueryContext(ctx, listAllHolonIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHolonsByLayer = `-- name: ListHolonsByLayer :many
SELECT id, type, kind, layer, title, content, context_id, scope, cached_r_score, created_at, updated_at FROM holons WHERE layer = ? ORDER BY created_at DESC
`

func (q *Queries) ListHolonsByLayer(ctx context.Context, db DBTX, layer string) ([]Holon, error) {
	rows, err := db.QueryContext(ctx, listHolonsByLayer, layer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Holon
	for rows.Next() {
		var i Holon
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.Layer,
			&i.Title,
			&i.Content,
			&i.ContextID,
			&i.Scope,
			&i.CachedRScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordWork = `-- name: RecordWork :exec

INSERT INTO work_records (id, method_ref, performer_ref, started_at, ended_at, resource_ledger, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type RecordWorkParams struct {
	ID             string
	MethodRef      string
	PerformerRef   string
	StartedAt      time.Time
	EndedAt        sql.NullTime
	ResourceLedger sql.NullString
	CreatedAt      sql.NullTime
}

// Work record queries
func (q *Queries) RecordWork(ctx context.Context, db DBTX, arg RecordWorkParams) error {
	_, err := db.ExecContext(ctx, recordWork,
		arg.ID,
		arg.MethodRef,
		arg.PerformerRef,
		arg.StartedAt,
		arg.EndedAt,
		arg.ResourceLedger,
		arg.CreatedAt,
	)
	return err
}

const updateHolonLayer = `-- name: UpdateHolonLayer :exec
UPDATE holons SET layer = ?, updated_at = ? WHERE id = ?
`

type UpdateHolonLayerParams struct {
	Layer     string
	UpdatedAt sql.NullTime
	ID        string
}

func (q *Queries) UpdateHolonLayer(ctx context.Context, db DBTX, arg UpdateHolonLayerParams) error {
	_, err := db.ExecContext(ctx, updateHolonLayer, arg.Layer, arg.UpdatedAt, arg.ID)
	return err
}

const updateHolonRScore = `-- name: UpdateHolonRScore :exec
UPDATE holons SET cached_r_score = ?, updated_at = ? WHERE id = ?
`

type UpdateHolonRScoreParams struct {
	CachedRScore sql.NullFloat64
	UpdatedAt    sql.NullTime
	ID           string
}

func (q *Queries) UpdateHolonRScore(ctx context.Context, db DBTX, arg UpdateHolonRScoreParams) error {
	_, err := db.ExecContext(ctx, updateHolonRScore, arg.CachedRScore, arg.UpdatedAt, arg.ID)
	return err
}
