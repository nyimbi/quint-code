// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addCharacteristic = `-- name: AddCharacteristic :exec

INSERT INTO characteristics (id, holon_id, name, scale, value, unit, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type AddCharacteristicParams struct {
	ID        string
	HolonID   string
	Name      string
	Scale     string
	Value     string
	Unit      sql.NullString
	CreatedAt sql.NullTime
}

// Characteristic queries
func (q *Queries) AddCharacteristic(ctx context.Context, db DBTX, arg AddCharacteristicParams) error {
	_, err := db.ExecContext(ctx, addCharacteristic,
		arg.ID,
		arg.HolonID,
		arg.Name,
		arg.Scale,
		arg.Value,
		arg.Unit,
		arg.CreatedAt,
	)
	return err
}

const addEvidence = `-- name: AddEvidence :exec

INSERT INTO evidence (id, holon_id, type, content, verdict, assurance_level, carrier_ref, valid_until, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type AddEvidenceParams struct {
	ID             string
	HolonID        string
	Type           string
	Content        string
	Verdict        string
	AssuranceLevel sql.NullString
	CarrierRef     sql.NullString
	ValidUntil     sql.NullTime
	CreatedAt      sql.NullTime
}

// Evidence queries
func (q *Queries) AddEvidence(ctx context.Context, db DBTX, arg AddEvidenceParams) error {
	_, err := db.ExecContext(ctx, addEvidence,
		arg.ID,
		arg.HolonID,
		arg.Type,
		arg.Content,
		arg.Verdict,
		arg.AssuranceLevel,
		arg.CarrierRef,
		arg.ValidUntil,
		arg.CreatedAt,
	)
	return err
}

const addRelation = `-- name: AddRelation :exec

INSERT INTO relations (source_id, target_id, relation_type, created_at)
VALUES (?, ?, ?, ?)
`

type AddRelationParams struct {
	SourceID     string
	TargetID     string
	RelationType string
	CreatedAt    sql.NullTime
}

// Relation queries
func (q *Queries) AddRelation(ctx context.Context, db DBTX, arg AddRelationParams) error {
	_, err := db.ExecContext(ctx, addRelation,
		arg.SourceID,
		arg.TargetID,
		arg.RelationType,
		arg.CreatedAt,
	)
	return err
}

const countHolonsByLayer = `-- name: CountHolonsByLayer :many
SELECT layer, COUNT(*) as count FROM holons WHERE context_id = ? GROUP BY layer
`

type CountHolonsByLayerRow struct {
	Layer string
	Count int64
}

func (q *Queries) CountHolonsByLayer(ctx context.Context, db DBTX, contextID string) ([]CountHolonsByLayerRow, error) {
	rows, err := db.QueryContext(ctx, countHolonsByLayer, contextID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountHolonsByLayerRow
	for rows.Next() {
		var i CountHolonsByLayerRow
		if err := rows.Scan(&i.Layer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createHolon = `-- name: CreateHolon :exec


INSERT INTO holons (id, type, kind, layer, title, content, context_id, scope, parent_id, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHolonParams struct {
	ID        string
	Type      string
	Kind      sql.NullString
	Layer     string
	Title     string
	Content   string
	ContextID string
	Scope     sql.NullString
	ParentID  sql.NullString
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
}

// query.sql
// sqlc queries for FPF database operations
// Holon queries
func (q *Queries) CreateHolon(ctx context.Context, db DBTX, arg CreateHolonParams) error {
	_, err := db.ExecContext(ctx, createHolon,
		arg.ID,
		arg.Type,
		arg.Kind,
		arg.Layer,
		arg.Title,
		arg.Content,
		arg.ContextID,
		arg.Scope,
		arg.ParentID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createRelation = `-- name: CreateRelation :exec
INSERT INTO relations (source_id, relation_type, target_id, congruence_level)
VALUES (?, ?, ?, ?)
ON CONFLICT(source_id, relation_type, target_id)
DO UPDATE SET congruence_level = excluded.congruence_level
`

type CreateRelationParams struct {
	SourceID        string
	RelationType    string
	TargetID        string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) CreateRelation(ctx context.Context, db DBTX, arg CreateRelationParams) error {
	_, err := db.ExecContext(ctx, createRelation,
		arg.SourceID,
		arg.RelationType,
		arg.TargetID,
		arg.CongruenceLevel,
	)
	return err
}

const createWaiver = `-- name: CreateWaiver :exec

INSERT INTO waivers (id, evidence_id, waived_by, waived_until, rationale, created_at)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateWaiverParams struct {
	ID          string
	EvidenceID  string
	WaivedBy    string
	WaivedUntil time.Time
	Rationale   string
	CreatedAt   sql.NullTime
}

// Waiver queries
func (q *Queries) CreateWaiver(ctx context.Context, db DBTX, arg CreateWaiverParams) error {
	_, err := db.ExecContext(ctx, createWaiver,
		arg.ID,
		arg.EvidenceID,
		arg.WaivedBy,
		arg.WaivedUntil,
		arg.Rationale,
		arg.CreatedAt,
	)
	return err
}

const getActiveWaiverForEvidence = `-- name: GetActiveWaiverForEvidence :one
SELECT id, evidence_id, waived_by, waived_until, rationale, created_at FROM waivers
WHERE evidence_id = ? AND waived_until > datetime('now')
ORDER BY waived_until DESC LIMIT 1
`

func (q *Queries) GetActiveWaiverForEvidence(ctx context.Context, db DBTX, evidenceID string) (Waiver, error) {
	row := db.QueryRowContext(ctx, getActiveWaiverForEvidence, evidenceID)
	var i Waiver
	err := row.Scan(
		&i.ID,
		&i.EvidenceID,
		&i.WaivedBy,
		&i.WaivedUntil,
		&i.Rationale,
		&i.CreatedAt,
	)
	return i, err
}

const getAllActiveWaivers = `-- name: GetAllActiveWaivers :many
SELECT id, evidence_id, waived_by, waived_until, rationale, created_at FROM waivers WHERE waived_until > datetime('now') ORDER BY waived_until ASC
`

func (q *Queries) GetAllActiveWaivers(ctx context.Context, db DBTX) ([]Waiver, error) {
	rows, err := db.QueryContext(ctx, getAllActiveWaivers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Waiver
	for rows.Next() {
		var i Waiver
		if err := rows.Scan(
			&i.ID,
			&i.EvidenceID,
			&i.WaivedBy,
			&i.WaivedUntil,
			&i.Rationale,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogByContext = `-- name: GetAuditLogByContext :many
SELECT id, timestamp, tool_name, operation, actor, target_id, input_hash, result, details, context_id FROM audit_log WHERE context_id = ? ORDER BY timestamp DESC
`

func (q *Queries) GetAuditLogByContext(ctx context.Context, db DBTX, contextID string) ([]AuditLog, error) {
	rows, err := db.QueryContext(ctx, getAuditLogByContext, contextID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.ToolName,
			&i.Operation,
			&i.Actor,
			&i.TargetID,
			&i.InputHash,
			&i.Result,
			&i.Details,
			&i.ContextID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogByTarget = `-- name: GetAuditLogByTarget :many
SELECT id, timestamp, tool_name, operation, actor, target_id, input_hash, result, details, context_id FROM audit_log WHERE target_id = ? ORDER BY timestamp DESC
`

func (q *Queries) GetAuditLogByTarget(ctx context.Context, db DBTX, targetID sql.NullString) ([]AuditLog, error) {
	rows, err := db.QueryContext(ctx, getAuditLogByTarget, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.ToolName,
			&i.Operation,
			&i.Actor,
			&i.TargetID,
			&i.InputHash,
			&i.Result,
			&i.Details,
			&i.ContextID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharacteristics = `-- name: GetCharacteristics :many
SELECT id, holon_id, name, scale, value, unit, created_at FROM characteristics WHERE holon_id = ?
`

func (q *Queries) GetCharacteristics(ctx context.Context, db DBTX, holonID string) ([]Characteristic, error) {
	rows, err := db.QueryContext(ctx, getCharacteristics, holonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Characteristic
	for rows.Next() {
		var i Characteristic
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Name,
			&i.Scale,
			&i.Value,
			&i.Unit,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionMembers = `-- name: GetCollectionMembers :many
SELECT source_id, congruence_level
FROM relations
WHERE target_id = ? AND relation_type = 'memberOf'
`

type GetCollectionMembersRow struct {
	SourceID        string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) GetCollectionMembers(ctx context.Context, db DBTX, targetID string) ([]GetCollectionMembersRow, error) {
	rows, err := db.QueryContext(ctx, getCollectionMembers, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionMembersRow
	for rows.Next() {
		var i GetCollectionMembersRow
		if err := rows.Scan(&i.SourceID, &i.CongruenceLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComponentsOf = `-- name: GetComponentsOf :many
SELECT source_id, congruence_level FROM relations
WHERE target_id = ? AND relation_type = 'componentOf'
`

type GetComponentsOfRow struct {
	SourceID        string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) GetComponentsOf(ctx context.Context, db DBTX, targetID string) ([]GetComponentsOfRow, error) {
	rows, err := db.QueryContext(ctx, getComponentsOf, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetComponentsOfRow
	for rows.Next() {
		var i GetComponentsOfRow
		if err := rows.Scan(&i.SourceID, &i.CongruenceLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependencies = `-- name: GetDependencies :many
SELECT target_id, relation_type, congruence_level
FROM relations
WHERE source_id = ? AND relation_type IN ('componentOf', 'constituentOf')
`

type GetDependenciesRow struct {
	TargetID        string
	RelationType    string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) GetDependencies(ctx context.Context, db DBTX, sourceID string) ([]GetDependenciesRow, error) {
	rows, err := db.QueryContext(ctx, getDependencies, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDependenciesRow
	for rows.Next() {
		var i GetDependenciesRow
		if err := rows.Scan(&i.TargetID, &i.RelationType, &i.CongruenceLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependents = `-- name: GetDependents :many
SELECT source_id, relation_type, congruence_level
FROM relations
WHERE target_id = ? AND relation_type IN ('componentOf', 'constituentOf')
`

type GetDependentsRow struct {
	SourceID        string
	RelationType    string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) GetDependents(ctx context.Context, db DBTX, targetID string) ([]GetDependentsRow, error) {
	rows, err := db.QueryContext(ctx, getDependents, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDependentsRow
	for rows.Next() {
		var i GetDependentsRow
		if err := rows.Scan(&i.SourceID, &i.RelationType, &i.CongruenceLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvidenceByHolon = `-- name: GetEvidenceByHolon :many
SELECT id, holon_id, type, content, verdict, assurance_level, carrier_ref, valid_until, created_at FROM evidence WHERE holon_id = ? ORDER BY created_at DESC
`

func (q *Queries) GetEvidenceByHolon(ctx context.Context, db DBTX, holonID string) ([]Evidence, error) {
	rows, err := db.QueryContext(ctx, getEvidenceByHolon, holonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evidence
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.Content,
			&i.Verdict,
			&i.AssuranceLevel,
			&i.CarrierRef,
			&i.ValidUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvidenceByID = `-- name: GetEvidenceByID :one
SELECT id, holon_id, type, content, verdict, assurance_level, carrier_ref, valid_until, created_at FROM evidence WHERE id = ? LIMIT 1
`

func (q *Queries) GetEvidenceByID(ctx context.Context, db DBTX, id string) (Evidence, error) {
	row := db.QueryRowContext(ctx, getEvidenceByID, id)
	var i Evidence
	err := row.Scan(
		&i.ID,
		&i.HolonID,
		&i.Type,
		&i.Content,
		&i.Verdict,
		&i.AssuranceLevel,
		&i.CarrierRef,
		&i.ValidUntil,
		&i.CreatedAt,
	)
	return i, err
}

const getEvidenceWithCarrier = `-- name: GetEvidenceWithCarrier :many
SELECT id, holon_id, type, content, verdict, assurance_level, carrier_ref, valid_until, created_at FROM evidence WHERE carrier_ref IS NOT NULL AND carrier_ref != ''
`

func (q *Queries) GetEvidenceWithCarrier(ctx context.Context, db DBTX) ([]Evidence, error) {
	rows, err := db.QueryContext(ctx, getEvidenceWithCarrier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evidence
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.Content,
			&i.Verdict,
			&i.AssuranceLevel,
			&i.CarrierRef,
			&i.ValidUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHolon = `-- name: GetHolon :one
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, created_at, updated_at FROM holons WHERE id = ? LIMIT 1
`

func (q *Queries) GetHolon(ctx context.Context, db DBTX, id string) (Holon, error) {
	row := db.QueryRowContext(ctx, getHolon, id)
	var i Holon
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Kind,
		&i.Layer,
		&i.Title,
		&i.Content,
		&i.ContextID,
		&i.Scope,
		&i.ParentID,
		&i.CachedRScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHolonLineage = `-- name: GetHolonLineage :many
WITH RECURSIVE lineage AS (
    SELECT h.id, h.type, h.kind, h.layer, h.title, h.content, h.context_id, h.scope, h.parent_id, h.cached_r_score, h.created_at, h.updated_at, 0 as depth
    FROM holons h WHERE h.id = ?
    UNION ALL
    SELECT p.id, p.type, p.kind, p.layer, p.title, p.content, p.context_id, p.scope, p.parent_id, p.cached_r_score, p.created_at, p.updated_at, l.depth + 1
    FROM holons p
    INNER JOIN lineage l ON p.id = l.parent_id
)
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, created_at, updated_at, depth FROM lineage ORDER BY depth DESC
`

type GetHolonLineageRow struct {
	ID           string
	Type         string
	Kind         sql.NullString
	Layer        string
	Title        string
	Content      string
	ContextID    string
	Scope        sql.NullString
	ParentID     sql.NullString
	CachedRScore sql.NullFloat64
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
	Depth        int64
}

func (q *Queries) GetHolonLineage(ctx context.Context, db DBTX, id string) ([]GetHolonLineageRow, error) {
	rows, err := db.QueryContext(ctx, getHolonLineage, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHolonLineageRow
	for rows.Next() {
		var i GetHolonLineageRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.Layer,
			&i.Title,
			&i.Content,
			&i.ContextID,
			&i.Scope,
			&i.ParentID,
			&i.CachedRScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHolonTitle = `-- name: GetHolonTitle :one
SELECT title FROM holons WHERE id = ? LIMIT 1
`

func (q *Queries) GetHolonTitle(ctx context.Context, db DBTX, id string) (string, error) {
	row := db.QueryRowContext(ctx, getHolonTitle, id)
	var title string
	err := row.Scan(&title)
	return title, err
}

const getHolonsByParent = `-- name: GetHolonsByParent :many
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, created_at, updated_at FROM holons WHERE parent_id = ? ORDER BY created_at DESC
`

func (q *Queries) GetHolonsByParent(ctx context.Context, db DBTX, parentID sql.NullString) ([]Holon, error) {
	rows, err := db.QueryContext(ctx, getHolonsByParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Holon
	for rows.Next() {
		var i Holon
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.Layer,
			&i.Title,
			&i.Content,
			&i.ContextID,
			&i.Scope,
			&i.ParentID,
			&i.CachedRScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestHolonByContext = `-- name: GetLatestHolonByContext :one
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, created_at, updated_at FROM holons WHERE context_id = ? ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) GetLatestHolonByContext(ctx context.Context, db DBTX, contextID string) (Holon, error) {
	row := db.QueryRowContext(ctx, getLatestHolonByContext, contextID)
	var i Holon
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Kind,
		&i.Layer,
		&i.Title,
		&i.Content,
		&i.ContextID,
		&i.Scope,
		&i.ParentID,
		&i.CachedRScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecentAuditLog = `-- name: GetRecentAuditLog :many
SELECT id, timestamp, tool_name, operation, actor, target_id, input_hash, result, details, context_id FROM audit_log ORDER BY timestamp DESC LIMIT ?
`

func (q *Queries) GetRecentAuditLog(ctx context.Context, db DBTX, limit int64) ([]AuditLog, error) {
	rows, err := db.QueryContext(ctx, getRecentAuditLog, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.ToolName,
			&i.Operation,
			&i.Actor,
			&i.TargetID,
			&i.InputHash,
			&i.Result,
			&i.Details,
			&i.ContextID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationsByTarget = `-- name: GetRelationsByTarget :many
SELECT source_id, target_id, relation_type, congruence_level, created_at FROM relations WHERE target_id = ? AND relation_type = ?
`

type GetRelationsByTargetParams struct {
	TargetID     string
	RelationType string
}

func (q *Queries) GetRelationsByTarget(ctx context.Context, db DBTX, arg GetRelationsByTargetParams) ([]Relation, error) {
	rows, err := db.QueryContext(ctx, getRelationsByTarget, arg.TargetID, arg.RelationType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Relation
	for rows.Next() {
		var i Relation
		if err := rows.Scan(
			&i.SourceID,
			&i.TargetID,
			&i.RelationType,
			&i.CongruenceLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWaiversByEvidence = `-- name: GetWaiversByEvidence :many
SELECT id, evidence_id, waived_by, waived_until, rationale, created_at FROM waivers WHERE evidence_id = ? ORDER BY created_at DESC
`

func (q *Queries) GetWaiversByEvidence(ctx context.Context, db DBTX, evidenceID string) ([]Waiver, error) {
	rows, err := db.QueryContext(ctx, getWaiversByEvidence, evidenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Waiver
	for rows.Next() {
		var i Waiver
		if err := rows.Scan(
			&i.ID,
			&i.EvidenceID,
			&i.WaivedBy,
			&i.WaivedUntil,
			&i.Rationale,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAuditLog = `-- name: InsertAuditLog :exec

INSERT INTO audit_log (id, tool_name, operation, actor, target_id, input_hash, result, details, context_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertAuditLogParams struct {
	ID        string
	ToolName  string
	Operation string
	Actor     string
	TargetID  sql.NullString
	InputHash sql.NullString
	Result    string
	Details   sql.NullString
	ContextID string
}

// Audit log queries
func (q *Queries) InsertAuditLog(ctx context.Context, db DBTX, arg InsertAuditLogParams) error {
	_, err := db.ExecContext(ctx, insertAuditLog,
		arg.ID,
		arg.ToolName,
		arg.Operation,
		arg.Actor,
		arg.TargetID,
		arg.InputHash,
		arg.Result,
		arg.Details,
		arg.ContextID,
	)
	return err
}

const listAllHolonIDs = `-- name: ListAllHolonIDs :many
SELECT id FROM holons
`

func (q *Queries) ListAllHolonIDs(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.QueryContext(ctx, listAllHolonIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHolonsByLayer = `-- name: ListHolonsByLayer :many
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, created_at, updated_at FROM holons WHERE layer = ? ORDER BY created_at DESC
`

func (q *Queries) ListHolonsByLayer(ctx context.Context, db DBTX, layer string) ([]Holon, error) {
	rows, err := db.QueryContext(ctx, listHolonsByLayer, layer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Holon
	for rows.Next() {
		var i Holon
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.Layer,
			&i.Title,
			&i.Content,
			&i.ContextID,
			&i.Scope,
			&i.ParentID,
			&i.CachedRScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordWork = `-- name: RecordWork :exec

INSERT INTO work_records (id, method_ref, performer_ref, started_at, ended_at, resource_ledger, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type RecordWorkParams struct {
	ID             string
	MethodRef      string
	PerformerRef   string
	StartedAt      time.Time
	EndedAt        sql.NullTime
	ResourceLedger sql.NullString
	CreatedAt      sql.NullTime
}

// Work record queries
func (q *Queries) RecordWork(ctx context.Context, db DBTX, arg RecordWorkParams) error {
	_, err := db.ExecContext(ctx, recordWork,
		arg.ID,
		arg.MethodRef,
		arg.PerformerRef,
		arg.StartedAt,
		arg.EndedAt,
		arg.ResourceLedger,
		arg.CreatedAt,
	)
	return err
}

const updateHolonLayer = `-- name: UpdateHolonLayer :exec
UPDATE holons SET layer = ?, updated_at = ? WHERE id = ?
`

type UpdateHolonLayerParams struct {
	Layer     string
	UpdatedAt sql.NullTime
	ID        string
}

func (q *Queries) UpdateHolonLayer(ctx context.Context, db DBTX, arg UpdateHolonLayerParams) error {
	_, err := db.ExecContext(ctx, updateHolonLayer, arg.Layer, arg.UpdatedAt, arg.ID)
	return err
}

const updateHolonRScore = `-- name: UpdateHolonRScore :exec
UPDATE holons SET cached_r_score = ?, updated_at = ? WHERE id = ?
`

type UpdateHolonRScoreParams struct {
	CachedRScore sql.NullFloat64
	UpdatedAt    sql.NullTime
	ID           string
}

func (q *Queries) UpdateHolonRScore(ctx context.Context, db DBTX, arg UpdateHolonRScoreParams) error {
	_, err := db.ExecContext(ctx, updateHolonRScore, arg.CachedRScore, arg.UpdatedAt, arg.ID)
	return err
}
